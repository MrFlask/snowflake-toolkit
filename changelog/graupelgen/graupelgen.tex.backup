\documentclass[a4paper,10pt]{scrartcl}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage{varioref}
\usepackage{hyperref}
\usepackage{cleveref}
\usepackage[intlimits]{amsmath}
\usepackage{amssymb}


\newcommand{\prgname}[1]{\texttt{#1}}
\newcommand{\dd}{\mathrm{d}}

%opening
\title{A graupel generation algorithm}
\author{Torbj√∂rn Rathsman}

\begin{document}

\maketitle
\begin{abstract}
This article describes an algorithm that can be used to generate graupel-like particles.
\end{abstract}



\tableofcontents

\section{Data representation} 
A graupel can be modelled as a spherical object, build of other spheres. While it is possible to store spheres as polygon meshes, it requires quite a large number of vertices to get a good approximation. Also, a graupel requires a large number of sub-volumes. Constructing a particle with a fill ratio of 0.3, and a radius of 100 sub-volumes, requires ... %Count subvolumes

Instead of using polygon meshes, the spheres are represented as a midpoint and a radius. The spheres are stored in a dynamic array.

\section{Generating a collision event}
A collision event is generated by choosing a random point on a sphere surrounding the aggregate. From that point, a ray is cast towards the aggregate. The idea is to attach a new sphere at the surface of the sphere closest to the ray origin.

Not all collisions need to result in a merge event. It may depend on the energy of the incoming particle, as will as the incidence angle. It is assumed that an incoming particle with a kinetic energy less than 1 sticks to the aggregate, and that an incidence angle of zero makes the incoming particle looses all of its kinetic energy, thus sticking to the aggregate. The relative loss of kinetic energy is taken as the cosine between the reversed direction of the ray, and the normal of the sub-volumes at the incidence point, that is the dot product between the two vectors. Moreover, if this dot product is negative, the intersection point is not considered. Thus, the algorithm implements backface culling.

The true nature of the process, is that incoming particles, that do not stick to the aggregate, must bounce of, loosing some of their kinetic energy, and acquire some heat. Implementing this is possible, but slow, so instead the kinetic energy is just modelled as an exponential of the travelled distance: The longer path, the smaller kinetic energy. The initial kinetic energy is taken as a uniformly distributed random number between 0 and a parameter $E_0$.

\section{Accepting collision events, and merging}
After a collision event has been generated, the incoming particle is pulled by a given amount towards the aggregate. This is necessary due to the fact that true spheres only touch each other in a point, and there has to be some surface area at the merge point. In addition to that, an overlap between other sub-volumes may also be accepted. If there are too many overlaps, the event is rejected.

\section{Formal description of the algorithm}
Let $S$ be the graupel. Formally, the algorithm can be described as follows.
\begin{enumerate}
 \item Place a sphere $S_0$ with random radius at the origin $O$
 \item Append $S_0$ to $S$
 \item While stop condition is false
 \begin{enumerate}
  \item Choose a point $P$ on a sphere surrounding $S$
  \item Define $r$ as the ray from $P$ through $O$. Let $\vec{v}=\frac{O-P}{|O - P|}$ be the direction vector of that ray.
  \item Draw a uniformly distributed random number $\epsilon$ between 0 and $E_0$
  \item Find the intersection point $P_0$ between $r$, and the sub-volume $S_1$ in $S$ closest to $P$. Also, call the normal of $S_1$ at $P_0$ $\vec{n}_1$.
  \item If overlap conditions are fulfilled
  \begin{enumerate}
  \item Append a new $S_0$ to $S$ so that $S_1$ $\vec{n}_1=-\vec{n}_2$
  \item Move $S_0$ a certain amount in the normal direction.
  \end{enumerate}
 \end{enumerate}
\end{enumerate}

In step 3c, the following test is used to determine whether or not a sub-volume should count.
\begin{itemize}
 \item If $\vec{n}_1\cdot\left(-\vec{v}\right) < 0$, the ray has hit the backface of the sub-volume, and the search continues.
 \item If $\vec{n}_1\cdot\left(-\vec{v}\right)\epsilon \exp\left(-\frac{t}{\tau}\right)>1$, the incoming particle is assumed to have passed, and the search continues. Here $t$ is the distance between $P$ and $P_0$, and $\tau$ is the decay distance.
 \item Otherwise, the the current sub-volume is a candidate
\end{itemize}

\section{Algorithmic complexity}
Since there is no certain geometrical order among the sub-volumes $N$ in $S$, the ray-caster needs $\mathcal{O}(N)$ iterations to find the nearest surface point. Furthermore, if the stop condition is in terms of $D_{max}$---the extent of the aggregate, the complexity becomes $\mathcal{O}(N\cdot N^3)=\mathcal{O}(N^4)$. This is because the volume grows linearly in $N$, and therefore the algorithm is quadratic if the volume is given as a stop condition. At the same time $V\propto D_\text{max}^3\iff D_\text{max}\propto V^{1/3}$. Thus, the algorithmic complexity is $\mathcal{O}(N^4)$.

\section{Improvements}
Through the use of spatial acceleration structures, the complexity of the ray-caster can be reduced from $\mathcal{O}(N)$ to $\mathcal{

\begin{thebibliography}{9}
\end{thebibliography}

\end{document}
